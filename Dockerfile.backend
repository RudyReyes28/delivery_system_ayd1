# --- Etapa 1: Construcción (Build Stage) ---
# Define un entorno temporal con todas las herramientas para compilar tu proyecto.
# Usamos una imagen oficial de Maven que ya incluye Java 24 (Eclipse Temurin).
FROM maven:3.9.6-eclipse-temurin-24 AS build

# Establece el directorio de trabajo dentro del contenedor.
WORKDIR /app

# Copia solo el archivo pom.xml de tu proyecto backend.
# Esto es un truco de caché: si las dependencias no cambian, Docker no las volverá a descargar.
COPY SistemasEntregas/pom.xml .

# Descarga todas las dependencias definidas en el pom.xml.
RUN mvn dependency:go-offline

# Ahora copia el resto del código fuente de tu backend.
COPY SistemasEntregas/src ./src

# Compila el código, ejecuta las pruebas (si las hay) y empaqueta la aplicación en un archivo .jar.
# -DskipTests se usa para acelerar el proceso en el pipeline.
RUN mvn clean package -DskipTests


# --- Etapa 2: Ejecución (Run Stage) ---
# Define la imagen final, que será mucho más ligera y segura.
# Usamos una imagen que solo contiene el Java Runtime (JRE), no el kit de desarrollo completo.
# 'alpine' es una versión de Linux muy pequeña, ideal para contenedores.
FROM eclipse-temurin:24-jre-alpine

# Establece el directorio de trabajo.
WORKDIR /app

# Copia ÚNICAMENTE el archivo .jar compilado desde la etapa 'build'.
# Esta es la magia del multi-stage build: ningún código fuente o herramienta de compilación llega a la imagen final.
COPY --from=build /app/target/*.jar app.jar

# Informa a Docker que el contenedor escuchará en el puerto 8080.
EXPOSE 8080

# Este es el comando que se ejecutará cuando el contenedor se inicie.
# Simplemente ejecuta la aplicación Spring Boot.
ENTRYPOINT ["java","-jar","app.jar"]```